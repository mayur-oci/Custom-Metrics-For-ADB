
set serveroutput on SIZE 100000;
-----------------------------------------------------------------

CREATE OR REPLACE FUNCTION GET_METRIC_DATA_DETAILS_JSON_OBJ (
    IN_ORDER_STATUS         IN VARCHAR2,
    IN_METRIC_CMPT_ID       IN VARCHAR2,
    IN_ADB_NAME             IN VARCHAR2,
    IN_METRIC_VALUE         IN NUMBER,
    IN_TS_METRIC_COLLECTION IN VARCHAR2
) RETURN JSON_OBJECT_T IS
    METRIC_DATA_DETAILS JSON_OBJECT_T;
    MDD_METADATA        JSON_OBJECT_T;
    MDD_DIMENSIONS      JSON_OBJECT_T;
    ARR_MDD_DATAPOINT   JSON_ARRAY_T;
    MDD_DATAPOINT       JSON_OBJECT_T;
BEGIN
    MDD_METADATA := JSON_OBJECT_T();
    MDD_METADATA.PUT('unit', 'TOTAL_ROW_COUNT'); -- metric unit is arbitrary, as per choice of developer

    MDD_DIMENSIONS := JSON_OBJECT_T();
    MDD_DIMENSIONS.PUT('dbname', IN_ADB_NAME);
    MDD_DIMENSIONS.PUT('schema_name', SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'));
    MDD_DIMENSIONS.PUT('table_name', 'SHOPPING_ORDER_TEST_final');
    MDD_DIMENSIONS.PUT('status_enum', IN_ORDER_STATUS);
    MDD_DATAPOINT := JSON_OBJECT_T();
    MDD_DATAPOINT.PUT('timestamp', IN_TS_METRIC_COLLECTION); --timestamp value RFC3339 compliant
    MDD_DATAPOINT.PUT('value', IN_METRIC_VALUE);
    MDD_DATAPOINT.PUT('count', 1);
    ARR_MDD_DATAPOINT := JSON_ARRAY_T();
    ARR_MDD_DATAPOINT.APPEND(MDD_DATAPOINT);
    METRIC_DATA_DETAILS := JSON_OBJECT_T();
    METRIC_DATA_DETAILS.PUT('datapoints', ARR_MDD_DATAPOINT);
    METRIC_DATA_DETAILS.PUT('metadata', MDD_METADATA);
    METRIC_DATA_DETAILS.PUT('dimensions', MDD_DIMENSIONS);

    -- namespace, resourceGroup and name for the custom metric are arbitrary values, as per choice of developer
    METRIC_DATA_DETAILS.PUT('namespace', 'adb_custom_metrics_111');
    METRIC_DATA_DETAILS.PUT('resourceGroup', 'adb_eco_group');
    METRIC_DATA_DETAILS.PUT('name', 'order_status');
    METRIC_DATA_DETAILS.PUT('compartmentId', IN_METRIC_CMPT_ID);
    RETURN METRIC_DATA_DETAILS;
END;
/

DECLARE
    COUNT_VAR NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO COUNT_VAR FROM ALL_TABLES WHERE TABLE_NAME = 'SHOPPING_ORDER_METRICS_TABLE';

    IF COUNT_VAR > 0 THEN
        DBMS_OUTPUT.PUT_LINE('TABLE EXISTS ALREADY!');
    ELSE
        -- table doesn't exist
        EXECUTE IMMEDIATE 'CREATE TABLE SHOPPING_ORDER_METRICS_TABLE(
                            ID                 NUMBER         GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
                            CREATED_DATE       TIMESTAMP(6)   DEFAULT CURRENT_TIMESTAMP,
                            STATUS             VARCHAR2(30 CHAR),
                            COUNT              NUMBER)';
    END IF;

END;
/

CREATE OR REPLACE FUNCTION PREPARE_JSON_OBJECT_FROM_METRIC_ROWS (
    OCI_METADATA_JSON_OBJ JSON_OBJECT_T
) RETURN JSON_OBJECT_T IS

    TOTAL_ORDERS_BY_STATUS_CNT     NUMBER := 0;
    COUNT_DATE                     TIMESTAMP(6);
    TOTAL_ROW_COUNT                NUMBER;
    OCI_POST_METRICS_BODY_JSON_OBJ JSON_OBJECT_T;
    TYPE STATUS_ARRAY IS
        VARRAY(8) OF VARCHAR2(30);
    ARRAY                          STATUS_ARRAY := STATUS_ARRAY('ACCEPTED', 'PAYMENT_REJECTED', 'SHIPPED', 'ABORTED', 'OUT_FOR_DELIVERY',
                                      'ORDER_DROPPED_NO_INVENTORY', 'PROCESSED', 'NOT_FULLFILLED');
    ARR_METRIC_DATA                JSON_ARRAY_T;
    METRIC_DATA_DETAILS            JSON_OBJECT_T;
BEGIN
    -- prepare JSON body for postmetrics api..
    -- for details please refer https://docs.oracle.com/en-us/iaas/api/#/en/monitoring/20180401/datatypes/PostMetricDataDetails
    ARR_METRIC_DATA := JSON_ARRAY_T();

    SELECT COUNT(*) INTO TOTAL_ROW_COUNT FROM SHOPPING_ORDER_METRICS_TABLE;
    DBMS_OUTPUT.PUT_LINE('TOTAL METRIC ROW COUNT IS '|| TOTAL_ROW_COUNT);

    -- PostMetrics api has soft limit of 50 unique metric stream per call, hence we cap it at 50. 
    -- For Production usecase where every metric data point is important, we can use chunking
    FOR METRIC_ROW IN (SELECT * FROM SHOPPING_ORDER_METRICS_TABLE 
                        ORDER BY CREATED_DATE DESC FETCH FIRST 50 ROWS ONLY) LOOP
         DBMS_OUTPUT.PUT_LINE('inside for loop ' || METRIC_ROW.STATUS );
        -- DBMS_OUTPUT.PUT_LINE('inside for loop ' || METRIC_ROW.STATUS || OCI_METADATA_JSON_OBJ.get_string('COMPARTMENT_OCID') ||
        -- OCI_METADATA_JSON_OBJ.get_string('DATABASE_NAME') || TO_CHAR(METRIC_ROW.CREATED_DATE, 'yyyy-mm-dd"T"hh24:mi:ss.ff3"Z"')
        -- );

        METRIC_DATA_DETAILS := GET_METRIC_DATA_DETAILS_JSON_OBJ(
                               METRIC_ROW.STATUS,
                               OCI_METADATA_JSON_OBJ.GET_STRING('COMPARTMENT_OCID'), 
                               OCI_METADATA_JSON_OBJ.GET_STRING('DATABASE_NAME'), 
                               METRIC_ROW.COUNT, 
                               TO_CHAR(METRIC_ROW.CREATED_DATE, 'yyyy-mm-dd"T"hh24:mi:ss.ff3"Z"'));
      --DBMS_OUTPUT.PUT_LINE('METRIC_DATA_DETAILS '|| METRIC_DATA_DETAILS.to_clob);
        ARR_METRIC_DATA.APPEND(METRIC_DATA_DETAILS);

    END LOOP;

      --DBMS_OUTPUT.PUT_LINE('ARR_METRIC_DATA '|| ARR_METRIC_DATA.to_clob);

    DBMS_OUTPUT.PUT_LINE('done with for loop ');

    --DBMS_OUTPUT.put_line(json_serialize((arr_metric_data.to_string)  varchar2 (4000) pretty));
    -- DBMS_OUTPUT.PUT_LINE(ARR_METRIC_DATA.TO_STRING);
    OCI_POST_METRICS_BODY_JSON_OBJ := JSON_OBJECT_T();
    OCI_POST_METRICS_BODY_JSON_OBJ.PUT('metricData', ARR_METRIC_DATA);
        --DBMS_OUTPUT.PUT_LINE('done with metricdata  ');

    DBMS_OUTPUT.PUT_LINE(OCI_POST_METRICS_BODY_JSON_OBJ.to_string);

    RETURN OCI_POST_METRICS_BODY_JSON_OBJ;
END;
/



CREATE OR REPLACE FUNCTION POST_METRICS_DATA_TO_OCI(OCI_POST_METRICS_BODY_JSON_OBJ JSON_OBJECT_T, ADB_REGION VARCHAR2) 
RETURN NUMBER 
IS
    RETRY_COUNT                    INTEGER := 0;
    MAX_RETRIES                    INTEGER := 3;
    RESP                           DBMS_CLOUD_TYPES.RESP;
    EXCEPTION_POSTING_METRICS      EXCEPTION;
    SLEEP_IN_SECONDS               INTEGER := 5;
    HTTP_CODE                      NUMBER;
BEGIN
    FOR RETRY_COUNT in 1..MAX_RETRIES  LOOP
            -- invoking REST endpoint for OCI Monitoring API
            -- for details please refer https://docs.oracle.com/en-us/iaas/api/#/en/monitoring/20180401/MetricData/PostMetricData
        RESP := DBMS_CLOUD.SEND_REQUEST(CREDENTIAL_NAME => 'OCI$RESOURCE_PRINCIPAL', 
                                        URI => 'https://telemetry-ingestion.'|| ADB_REGION|| '.oraclecloud.com/20180401/metrics', 
                                        METHOD =>DBMS_CLOUD.METHOD_POST, 
                                        BODY => UTL_RAW.CAST_TO_RAW(OCI_POST_METRICS_BODY_JSON_OBJ.TO_STRING));

        IF DBMS_CLOUD.GET_RESPONSE_STATUS_CODE(RESP) = 200 THEN    -- when it is 200 from OCI Metrics API, all good
            DBMS_OUTPUT.PUT_LINE('POSTED METRICS SUCCESSFULLY TO OCI MONIOTRING');
            RETURN 200;
        ELSIF DBMS_CLOUD.GET_RESPONSE_STATUS_CODE(RESP) = 429 THEN -- 429 is caused by throttling
            IF RETRY_COUNT < MAX_RETRIES THEN
                -- increase sleep time for each retry, doing exponential backoff
                DBMS_LOCK.SLEEP(POWER(SLEEP_IN_SECONDS, RETRY_COUNT+1));
                DBMS_OUTPUT.PUT_LINE('RETRYING THE POSTMETRICS API CALL');
            ELSE
                DBMS_OUTPUT.PUT_LINE('ABANDONING POSTMETRICS CALLS, AFTER 3 RETRIES, CAUSED BY THROTTLING, WILL BERETRIED IN NEXT SCHEDULED RUN');
                RETURN 429;
            END IF;
        ELSE -- for any other http status code....1. log error, 2. raise exception and then quit posting metrics, as it is most probably a persistent error 
                DBMS_OUTPUT.PUT_LINE('IRRECOVERABLE ERROR HAPPENED WHEN POSTING METRICS TO OCI MONITORING, PLEASE SEE CONSOLE FOR ERRORS');
                -- Response Body in TEXT format
                DBMS_OUTPUT.put_line('Body: ' || '------------' || CHR(10) || DBMS_CLOUD.get_response_text(resp) || CHR(10));
                -- Response Headers in JSON format
                DBMS_OUTPUT.put_line('Headers: ' || CHR(10) || '------------' || CHR(10) || DBMS_CLOUD.get_response_headers(resp).to_clob || CHR(10));
                -- Response Status Code
                DBMS_OUTPUT.put_line('Status Code: ' || CHR(10) || '------------' || CHR(10) || DBMS_CLOUD.get_response_status_code(resp));
                RETURN 500;
        END IF;

    END LOOP;
END;
/

CREATE OR REPLACE PROCEDURE COMPUTE_AND_BUFFER_METRICS IS
    OCI_METADATA_JSON_RESULT       VARCHAR2(1000);
    OCI_METADATA_JSON_OBJ          JSON_OBJECT_T;
    ADB_REGION                     VARCHAR2(25);
    OCI_POST_METRICS_BODY_JSON_OBJ JSON_OBJECT_T;
    RESP                           DBMS_CLOUD_TYPES.RESP;
    ATTEMPT                        INTEGER := 0;
    EXCEPTION_POSTING_METRICS      EXCEPTION;
    SLEEP_IN_SECONDS               INTEGER := 5;
BEGIN

    LOCK TABLE SHOPPING_ORDER_METRICS_TABLE IN EXCLUSIVE MODE;
    
    -- compute simple metric for getting count order by order-status 
    -- and store in buffer table SHOPPING_ORDER_METRICS_TABLE
    INSERT INTO SHOPPING_ORDER_METRICS_TABLE (STATUS, COUNT, CREATED_DATE) 
      SELECT STATUS, COUNT(*), SYSTIMESTAMP AT TIME ZONE 'UTC' FROM SHOPPING_ORDER SO GROUP BY SO.STATUS;
    
    -- we buffer at most 1000 metric points, please configure as per your needs
    DELETE FROM SHOPPING_ORDER_METRICS_TABLE SOMT WHERE SOMT.ID NOT IN
        (SELECT ID FROM SHOPPING_ORDER_METRICS_TABLE ORDER BY CREATED_DATE FETCH FIRST 1000 ROWS ONLY);
    
    COMMIT;    


    DBMS_OUTPUT.PUT_LINE('compute done');

    -- get the meta-data for this ADB Instance like its OCI compartmentId, region and DBName etc; as JSON in oci_metadata_json_result
    SELECT CLOUD_IDENTITY INTO OCI_METADATA_JSON_RESULT FROM V$PDBS; 
    -- dbms_output.put_line(oci_metadata_json_result);

    -- convert the JSON string into PLSQL JSON native JSON datatype json_object_t variable named oci_metadata_json_result
    OCI_METADATA_JSON_OBJ := JSON_OBJECT_T.PARSE(OCI_METADATA_JSON_RESULT);

    -- convert the computed metrics to JSON string, with OCI metadata for additional decoration
    OCI_POST_METRICS_BODY_JSON_OBJ := PREPARE_JSON_OBJECT_FROM_METRIC_ROWS(OCI_METADATA_JSON_OBJ);

    DBMS_OUTPUT.PUT_LINE('got json done');

    ADB_REGION := OCI_METADATA_JSON_OBJ.GET_STRING('REGION');
    DBMS_OUTPUT.PUT_LINE('got ADB_REGION done' || ADB_REGION);

    -- POST_METRICS_DATA_TO_OCI(OCI_POST_METRICS_BODY_JSON_OBJ JSON_OBJECT_T, ADB_REGION VARCHAR2) 
    --DELETE FROM SHOPPING_ORDER_METRICS_TABLE; COMMIT;   
END;
/



----------------------------------------------------



BEGIN
    --DELETE FROM SHOPPING_ORDER_METRICS_TABLE;
    EXECUTE IMMEDIATE 'ANALYZE TABLE SHOPPING_ORDER_METRICS_TABLE COMPUTE STATISTICS';

    ECOMMERCE_USER.POST_METRICS_TO_OCI();
END;

    --SELECT CLOUD_IDENTITY  FROM V$PDBS; 
    -- SELECT COUNT(*)  FROM SHOPPING_ORDER_METRICS_TABLE;
