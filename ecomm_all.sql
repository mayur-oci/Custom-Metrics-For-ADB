SET SERVEROUTPUT ON;

DROP TABLE SHOPPING_ORDER;

CREATE TABLE SHOPPING_ORDER
(
    ID                 NUMBER         GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    CREATED_DATE       TIMESTAMP(6)   DEFAULT CURRENT_TIMESTAMP,
    DETAILS            VARCHAR2(1000) DEFAULT NULL,
    LAST_UPDATED_DATE  TIMESTAMP(6)   DEFAULT CURRENT_TIMESTAMP,
    STATUS             VARCHAR2(30 CHAR),
    TOTAL_CHARGES      FLOAT          DEFAULT 0.0,
    CUSTOMER_ID        NUMBER(19)     
)
PARTITION BY LIST(STATUS)
    (PARTITION ACCEPTED VALUES ('ACCEPTED'),
    PARTITION PAYMENT_REJECTED VALUES ('PAYMENT_REJECTED'),
    PARTITION SHIPPED VALUES('SHIPPED'),
    PARTITION ABORTED VALUES('ABORTED'),
    PARTITION OUT_FOR_DELIVERY VALUES('OUT_FOR_DELIVERY'),
    PARTITION ORDER_DROPPED_NO_INVENTORY VALUES('ORDER_DROPPED_NO_INVENTORY'),
    PARTITION PROCESSED VALUES('PROCESSED'),
    PARTITION NOT_FULLFILLED VALUES('NOT_FULLFILLED')
    );
/

ALTER TABLE SHOPPING_ORDER ENABLE ROW MOVEMENT;


CREATE OR REPLACE PROCEDURE populate_data_feed IS
  arr_status_random_index INTEGER;
  customer_id_random INTEGER;
  type STATUS_ARRAY IS VARRAY(8) OF VARCHAR2(30); 
  array STATUS_ARRAY := STATUS_ARRAY('ACCEPTED','PAYMENT_REJECTED', 'SHIPPED', 'ABORTED', 
                               'OUT_FOR_DELIVERY', 'ORDER_DROPPED_NO_INVENTORY', 
                               'PROCESSED', 'NOT_FULLFILLED');
  total_rows_in_shopping_order INTEGER := 10000;  
  
  type rowid_nt is table of rowid;
  rowids rowid_nt;
BEGIN     
  -- starting from scratch just be idempotent and have predictable execution time for this stored procedure
  -- deleting existing rows is optional 
  DELETE SHOPPING_ORDER;
   
  -- insert data
  FOR counter IN 1..total_rows_in_shopping_order LOOP
           arr_status_random_index := TRUNC(dbms_random.value(low => 1, high => 9));
           customer_id_random := TRUNC(dbms_random.value(low => 1, high => 8000));
           INSERT INTO SHOPPING_ORDER(STATUS, CUSTOMER_ID)
                     VALUES(array(arr_status_random_index), customer_id_random);
           COMMIT;          
           --DBMS_LOCK.SLEEP(1);          
  END LOOP;
  dbms_output.put_line('Done with initial data load');

  -- keep on updating the same data
  FOR counter IN 1..7000 LOOP        
            
            --Get the rowids
            SELECT r bulk collect into rowids
            FROM (
                SELECT ROWID r
                FROM SHOPPING_ORDER sample(5)
                ORDER BY dbms_random.value
            )RNDM WHERE rownum < total_rows_in_shopping_order+1;
            
            --update the table
            arr_status_random_index := TRUNC(dbms_random.value(low => 1, high => 9));
            for i in 1 .. rowids.count LOOP
                update SHOPPING_ORDER SET STATUS=array(arr_status_random_index)
                where rowid = rowids(i);
                COMMIT;          
            END LOOP;    
         
            --DBMS_LOCK.SLEEP(ROUND(dbms_random.value(low => 1, high => 2)));          
  END LOOP;
  dbms_output.put_line('Done with data feed');

  EXECUTE IMMEDIATE 'ANALYZE TABLE SHOPPING_ORDER COMPUTE STATISTICS';

END;
/


BEGIN
    -- DBMS_SCHEDULER.STOP_JOB(job_name => 'POPULATE_DATA_FEED');
    --- DBMS_SCHEDULER.DROP_JOB(job_name => 'POPULATE_DATA_FEED');
    DBMS_SCHEDULER.CREATE_JOB(  
      JOB_NAME      =>  'POPULATE_DATA_FEED_JOB',  
      JOB_TYPE      =>  'STORED_PROCEDURE',  
      JOB_ACTION    =>  'POPULATE_DATA_FEED',  
      ENABLED       =>  TRUE,  
      AUTO_DROP     =>  TRUE,  
      COMMENTS      =>  'ONE-TIME JOB');
END;
/

SELECT * FROM SYS.DBA_JOBS_RUNNING;


-----------------------------------------------------------------

CREATE OR REPLACE FUNCTION get_metric_data_details_json_obj(
    in_order_status IN VARCHAR2, 
    in_metric_cmpt_id IN VARCHAR2, 
    in_adb_name IN VARCHAR2,
    in_metric_value IN NUMBER,
    in_ts_metric_collection IN VARCHAR2) 
RETURN json_object_t
IS
    metric_data_details        json_object_t;
    mdd_metadata               json_object_t;
    mdd_dimensions             json_object_t;
    arr_mdd_datapoint          json_array_t;
    mdd_datapoint              json_object_t;
BEGIN

    mdd_metadata := json_object_t();
    mdd_metadata.put('unit', 'total_row_count'); -- metric unit is arbitrary, as per choice of developer

    mdd_dimensions := json_object_t();
    mdd_dimensions.put('dbname', in_adb_name);
    mdd_dimensions.put('schema_name', SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'));
    mdd_dimensions.put('table_name', 'SHOPPING_ORDER_TEST');
    mdd_dimensions.put('status_enum', in_order_status);

    mdd_datapoint := json_object_t();
    mdd_datapoint.put('timestamp', in_ts_metric_collection); --timestamp value RFC3339 compliant
    mdd_datapoint.put('value', in_metric_value);
    mdd_datapoint.put('count', 1);
    arr_mdd_datapoint := json_array_t();
    arr_mdd_datapoint.append(mdd_datapoint);

    metric_data_details := json_object_t();

    metric_data_details.put('datapoints', arr_mdd_datapoint);
    metric_data_details.put('metadata', mdd_metadata);
    metric_data_details.put('dimensions', mdd_dimensions);

    -- namespace, resourceGroup and name for the custom metric are arbitrary values, as per choice of developer
    metric_data_details.put('namespace', 'atp_custom_metrics_ns_30');
    metric_data_details.put('resourceGroup', 'adb_eco_group');
    metric_data_details.put('name', 'order_status');
    metric_data_details.put('compartmentId', in_metric_cmpt_id);

    RETURN metric_data_details;
END;
/



CREATE OR REPLACE FUNCTION compute_metric_and_prepare_json_object(
    oci_metadata_json_obj      json_object_t) 
RETURN json_object_t
IS
    total_orders_by_status_cnt  NUMBER := 0;

    oci_post_metrics_body_json_obj  json_object_t;
    type STATUS_ARRAY IS VARRAY(8) OF VARCHAR2(30); 
    array STATUS_ARRAY := STATUS_ARRAY('ACCEPTED','PAYMENT_REJECTED', 'SHIPPED', 'ABORTED', 
                               'OUT_FOR_DELIVERY', 'ORDER_DROPPED_NO_INVENTORY', 
                               'PROCESSED', 'NOT_FULLFILLED');
    arr_metric_data            json_array_t;
    metric_data_details        json_object_t;                
BEGIN
    -- prepare JSON body for postmetrics api..
    -- for details please refer https://docs.oracle.com/en-us/iaas/api/#/en/monitoring/20180401/datatypes/PostMetricDataDetails
    arr_metric_data := json_array_t();

    LOCK TABLE SHOPPING_ORDER IN EXCLUSIVE MODE; 
    FOR indx in 1..array.count LOOP
      SELECT COUNT(*) INTO total_orders_by_status_cnt FROM SHOPPING_ORDER SO WHERE SO.STATUS=array(indx);

      metric_data_details := get_metric_data_details_json_obj(
                                array(indx),
                                -- 'ocid1.compartment.oc1..aaaaaaaa2z4wup7a4enznwxi3mkk55cperdk3fcotagepjnan5utdb3tvakq',
                                oci_metadata_json_obj.get_string('COMPARTMENT_OCID'),
                                oci_metadata_json_obj.get_string('DATABASE_NAME'),
                                total_orders_by_status_cnt,
                                TO_CHAR(SYSTIMESTAMP AT TIME ZONE 'UTC', 'yyyy-mm-dd"T"hh24:mi:ss.ff3"Z"')
                            );

      arr_metric_data.append(metric_data_details);

    END LOOP;

    ROLLBACK; -- to  unlock SHOPPING_ORDER 

    --DBMS_OUTPUT.put_line(json_serialize((arr_metric_data.to_string)  varchar2(4000) pretty));
    DBMS_OUTPUT.put_line(arr_metric_data.to_string);
    oci_post_metrics_body_json_obj := json_object_t();
    oci_post_metrics_body_json_obj.put('metricData', arr_metric_data);

    RETURN oci_post_metrics_body_json_obj;
END;
/    

CREATE OR REPLACE PROCEDURE post_metrics_to_oci
    IS
    oci_metadata_json_result       VARCHAR2(1000);
    oci_metadata_json_obj          json_object_t; 

    adb_region                     VARCHAR2(25);
    oci_post_metrics_body_json_obj json_object_t;
    resp                           dbms_cloud_types.RESP;
    attempt                        INTEGER                := 0;
    EXCEPTION_POSTING_METRICS      EXCEPTION;
    SLEEP_IN_SECONDS               INTEGER                := 5;

BEGIN
    -- get the meta-data for this ADB Instance like its OCI compartmentId, region and DBName etc; as JSON in oci_metadata_json_result
    SELECT CLOUD_IDENTITY INTO OCI_METADATA_JSON_RESULT FROM V$PDBS; 
    -- dbms_output.put_line(oci_metadata_json_result);

    -- convert the JSON string into PLSQL JSON native JSON datatype json_object_t variable named oci_metadata_json_result
    oci_metadata_json_obj := json_object_t.parse(oci_metadata_json_result);
    oci_post_metrics_body_json_obj := compute_metric_and_prepare_json_object(oci_metadata_json_obj);
    
    adb_region := oci_metadata_json_obj.get_string('REGION');
    WHILE (TRUE)
        LOOP
            -- invoking REST endpoint for OCI Monitoring API
            -- for details please refer https://docs.oracle.com/en-us/iaas/api/#/en/monitoring/20180401/MetricData/PostMetricData
            resp := dbms_cloud.send_request(
                    credential_name => 'OCI$RESOURCE_PRINCIPAL',
                    uri => 'https://telemetry-ingestion.' || adb_region || '.oraclecloud.com/20180401/metrics',
                    method => dbms_cloud.METHOD_POST,
                    body => UTL_RAW.cast_to_raw(oci_post_metrics_body_json_obj.to_string));

            IF DBMS_CLOUD.get_response_status_code(resp) = 200 THEN    -- when it is 200 from OCI Metrics API, all good
                DBMS_OUTPUT.put_line('Posted metrics successfully to OCI moniotring');
                EXIT;
            ELSIF DBMS_CLOUD.get_response_status_code(resp) = 429 THEN -- 429 is caused by throttling
                attempt := attempt + 1;
                IF attempt <= 3 THEN
                    DBMS_LOCK.SLEEP(SLEEP_IN_SECONDS * attempt);       -- increase sleep time for each retry, doing exponential backoff
                    DBMS_OUTPUT.put_line('retrying the postmetrics api call');
                ELSE
                    DBMS_OUTPUT.put_line('Abandoning postmetrics calls, after 3 retries, caused by throttling');
                    EXIT;
                END IF;
            ELSE -- for any other http status code....1. log error, 2. raise exception and then quit posting metrics, as it is most probably a persistent error 
                -- Response Body in TEXT format
                DBMS_OUTPUT.put_line('Body: ' || '------------' || CHR(10) || DBMS_CLOUD.get_response_text(resp) || CHR(10));
                -- Response Headers in JSON format
                DBMS_OUTPUT.put_line('Headers: ' || CHR(10) || '------------' || CHR(10) || DBMS_CLOUD.get_response_headers(resp).to_clob || CHR(10));
                -- Response Status Code
                DBMS_OUTPUT.put_line('Status Code: ' || CHR(10) || '------------' || CHR(10) || DBMS_CLOUD.get_response_status_code(resp));
                RAISE EXCEPTION_POSTING_METRICS;

            END IF;
        END LOOP;


EXCEPTION
    WHEN EXCEPTION_POSTING_METRICS THEN
        dbms_output.put_line('Irrecoverable Error Happened when posting metrics to OCI Monitoring, please see console for errors');
    WHEN others THEN
        dbms_output.put_line('Error!!!, please see console for errors');
END;
/


BEGIN
  DBMS_SCHEDULER.CREATE_JOB (
   job_name           =>  'POST_METRICS_TO_OCI_JOB',
   job_type           =>  'STORED_PROCEDURE',
   job_action         =>  'POST_METRICS_TO_OCI',
   start_date         =>   SYSTIMESTAMP,
   repeat_interval    =>  'FREQ=SECONDLY;INTERVAL=60', /* every 10th second */
   end_date           =>   SYSTIMESTAMP + INTERVAL '1200' SECOND,  /* in production prefer end_date instead or skip it alltogether */
   auto_drop          =>   TRUE,
   enabled            =>   TRUE,
   comments           =>  'job to post db metrics to oci monitoring service, runs every 10th second');
END;
/

----------------------------------------------------

-- see status of jobs 

SELECT JOB_NAME, JOB_CLASS, OPERATION, STATUS FROM USER_SCHEDULER_JOB_LOG WHERE JOB_NAME LIKE2 'POPULATE%' OR JOB_NAME LIKE2 'POST_METRICS%';
SELECT * FROM ALL_SCHEDULER_JOB_RUN_DETAILS 
WHERE OWNER='ECOMMERCE_USER' AND JOB_NAME LIKE2 'POPULATE%'  ORDER BY LOG_DATE DESC;

SELECT * FROM ALL_SCHEDULER_JOB_RUN_DETAILS 
WHERE OWNER='ECOMMERCE_USER' AND JOB_NAME LIKE2 'POST_METRICS%' ORDER BY LOG_DATE DESC;

SELECT OWNER AS SCHEMA_NAME,
       JOB_NAME,
       JOB_STYLE,
       CASE WHEN JOB_TYPE IS NULL 
                 THEN 'PROGRAM'
            ELSE JOB_TYPE END AS JOB_TYPE,  
       CASE WHEN JOB_TYPE IS NULL
                 THEN PROGRAM_NAME
                 ELSE JOB_ACTION END AS JOB_ACTION,
       START_DATE,
       CASE WHEN REPEAT_INTERVAL IS NULL
            THEN SCHEDULE_NAME
            ELSE REPEAT_INTERVAL END AS SCHEDULE,
       LAST_START_DATE,
       NEXT_RUN_DATE,
       STATE
FROM SYS.ALL_SCHEDULER_JOBS
WHERE OWNER = 'ECOMMERCE_USER'
ORDER BY OWNER,
         JOB_NAME;


--SELECT CLOUD_IDENTITY  FROM V$PDBS; 

-- just for our information
SELECT STATUS,count(*) FROM SHOPPING_ORDER GROUP BY STATUS;
SELECT count(*) FROM SHOPPING_ORDER;




      --DBMS_SCHEDULER.DROP_JOB(job_name => 'POPULATE_DATA_FEED__');
    --DBMS_SCHEDULER.STOP_JOB(job_name => 'POPULATE_DATA_FEED__');
    --SELECT * FROM SYS.DBA_JOBS_RUNNING;
    --DBMS_SCHEDULER.DROP_JOB(job_name => 'POPULATE_DATA_FEED', force => true);


